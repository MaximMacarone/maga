### Экономия кода программ при наследовании.
Механизм наследования классов позволяет строить иерархии, в которых производные классы получают элементы родительских, или базовых, классов и могут дополнять их или изменять их свойства. При большом количестве никак не связанных классов управлять ими становится невозможным. Наследование позволяет справиться с этой проблемой путем упорядочивания и ранжирования классов, то есть объединения общих для нескольких классов свойств в одном классе и использования его в качестве базового.
Наследование классов подразумевает и наследование всех методов и полей базвого класса, что в свою очередь означает, что программисту нет необходимости описывать поля и методы производного класса снова, что экономит код.
### Виртуальные функции (методы). Экономия кода с использованием виртуальных функций.
В C++ реализован механизм _позднего_ _связывания,_ когда разрешение ссылок на метод происходит на этапе выполнения программы в зависимости от конкретного типа объекта, вызвавшего метод. Этот механизм реализован с помощью виртуальных методов
Для определения _виртуального метода_ используется спецификатор virtual

• Если в базовом классе метод определен как виртуальный, метод, определенный в производном классе с _тем же_ _именем_ _и_ _набором_ _параметров,_ автоматически становится виртуальным, а с _отличающимся набором параметров_ _—_ обычным.

• Виртуальные методы _наследуются,_ то есть переопределять их в производном классе требуется только при необходимости задать отличающиеся действия.
Права доступа при переопределении изменить нельзя.

• Если виртуальный метод переопределен в производном классе, объекты этого класса могут получить доступ к методу базового класса с помощью операции доступа к области видимости.

• Виртуальный метод не может объявляться с модификатором static, но может быть объявлен как дружественный.

• Если в классе вводится описание виртуального метода, он должен быть определен хотя бы как чисто виртуальный.

Итак, _виртуальным называется методу ссылка_ _на_ _который разрешается_ _на_ _этапе_ _выполнения программы_

_Чисто виртуальный метод_ содержит признак = 0 вместо тела, например:

virtual void f(int) = 0;

Чисто виртуальный метод должен переопределяться в производном классе (возможно, опять как чисто виртуальный).

Для каждого класса (не объекта!), содержащего хотя бы один виртуальный метод, компилятор создает _таблицу виртуальных методов_ ( vtbl ), в которой для каждого виртуального метода записан его адрес в памяти. Адреса методов содержатся в таблице в порядке их описания в классах. Адрес любого виртуального метода имеет в vtbl одно и то же смещение для каждого класса в пределах иерархии.

Каждый объект содержит скрытое дополнительное _поле ссылки_ на vtbl, называемое vptr. Оно заполняется конструктором при создании объекта

На этапе компиляции ссылки на виртуальные методы заменяются на обращения к vtbl через vptrобъекта, а на этапе выполнения в момент обращения к методу его адрес выбирается из таблицы. Таким образом, вызов виртуального метода, в отличие от обычных методов и функций, выполняется через дополнительный этап получения адреса метода из таблицы. Это несколько замедляет выполнение программы, поэтому без необходимости делать методы виртуальными смысла не имеет.