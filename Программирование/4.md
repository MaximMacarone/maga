### Перегрузка методов. 
C++ позволяет переопределить действие большинства операций так, чтобы при использовании с объектами конкретного класса они выполняли заданные функции.
Эта дает возможность использовать собственные типы дарпхых точно так же, как стандартные. Обозначения собственных операций вводить нельзя. Можно перегружать любые операции, существующие в C++

Часто бывает удобно, чтобы функции, реализующие один и тот же алгоритм для различных типов данных, имели одно и то же имя. Если это имя мнемонично, то есть несет нужную информацию, это делает программу более понятной, поскольку для каждого действия требуется помнить только одно имя. Использование не скольких функций с одним и тем же именем, но с различными типами параметров, называется _перегрузкой_ _функций._
Компилятор определяет, какую именно функцию требуется вызвать, по типу фактических параметров. Этот процесс называется разрешением перегрузки (перевод английского слова resolution в смысле «уточнение»). Тип возвращаемого функцией значения в разрешении не участвует. Механизм разрешения основан на достаточно сложном наборе правил, смысл которых сводится к тому, чтобы использовать функцию с наиболее подходящими аргументами и выдать сообщение, если такой не найдется.

Если соответствие на одном и том же этапе может быть получено более чем одним способом, вызов считается неоднозначным и выдается сообщение об ошибке. Неоднозначность может появиться при:
- преобразовании типа;
-  использовании параметров-ссылок;
- использовании аргументов по умолчанию.

Ниже приведены правила описания перегруженных функций.

- Перегруженные функции должны находиться _в одной области видимости,_ иначе произойдет сокрытие аналогично одинаковым именам переменных во вложенных блоках.
- Перегруженные функции могут иметь _параметры по умолчанию,_ при этом значения одного и того же параметра в разных функциях должны совпадать.
- В различных вариантах перегруженных функций может быть различное количество параметров по умолчанию.
- Функции не могут быть перегружены, если описание их параметров отличается только _модификатором_ const или _использованием ссылки_ (например, int и const int или int и int&).
### Инкапсуляция, наследование, полиморфизм в объектно-ориентированном программировании. 

Объединение данных с функциями их обработки в сочетании со скрытием ненужной для использования этих данных информации называется _инкапсуляцией_ ( encapsulation ). Инкапсуляция повышает степень абстракции программы: данные класса и реализация его функций находятся ниже уровня абстракции, и при написании программы информация о них не нужна. Кроме того, инкапсуляция позволяет изменить реализацию класса без модификации основной части программы, если интерфейс остался прежним

_Наследование_ - возможность создания иерархии классов, когда потомки наследуют все свойства своих предков, могут их изменять и добавлять новые. Свойства при наследовании повторно не описываются, что сокращает объем программы
Иерархия классов представляется в виде древовидной структуры, в которой более общие классы располагаются ближе к корню, а более специализированные - на ветвях и листьях. В С++ каждый классможет иметь сколько угодно потомков и предков. Иногда предки называются надклассами или суперклассами, а потомки - подклассами или субклассами.

Третьим китом, на котором стоит ООП, является _полиморфизм_ - возможность использовать в различных классах иерархии одно имя для обозначения сходных по смыслу действий и гибко выбирать требуемое действие во время выполнения программы.

Понятие полиморфизма используется в С++ весьма широко. Простым примером полиморфизма может служить перегрузка функций, когда из нескольких вариантов выбирается наиболее подходящая функция по соответствию ее прототипа передаваемым параметрам. Другой пример - использование шаблонов функций, когда один и тот же код видоизменяется в соответствии с типом, переданным в качестве параметра. Чаще всего понятие полиморфизма связывают с механизмом виртуальных методов.
### Защищённые компоненты класса. 

![[Снимок экрана 2025-08-06 в 16.06.45.png]]


### Переопределение методов