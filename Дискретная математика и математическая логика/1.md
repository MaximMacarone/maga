### Алгоритм Дейкстры.
Алгоритм Дейкстры (англ. _Dijkstra’s algorithm_) находит кратчайшие пути от заданной вершины ss до всех остальных в графе без ребер отрицательного веса.

Алгоритм Дейкстры начинается с установки начальной вершины и работы от этой точки. Он работает по принципу «жадного» алгоритма, что означает, что на каждом шаге он стремится минимизировать текущую общую стоимость пути.  
  
Сначала инициализируются два множества:  

- Множество, содержащее уже обработанные вершины (изначально пустое).
- Множество, содержащее все остальные вершины графа (изначально содержит все вершины графа).

  
Также каждой вершине графа присваивается вес, который представляет минимальную известную стоимость пути от начальной вершины до данной. Для начальной вершины этот вес равен 0, для всех остальных вершин — бесконечность.  
  
На каждом шаге алгоритм выбирает вершину из непосещенного множества с наименьшим весом, перемещает эту вершину в множество посещенных вершин и обновляет веса всех соседей выбранной вершины. Вес соседа обновляется, если через выбранную вершину можно добраться до этого соседа с меньшей стоимостью.  
  
Процесс продолжается, пока не будут посещены все вершины или пока мы не найдем путь до конечной вершины

![[Снимок экрана 2025-08-05 в 00.05.03.png]]
Возьмем в качестве источника вершину 1. Это значит что мы будем искать кратчайшие маршруты из вершины 1 в вершины 2, 3, 4 и 5.  
Данный алгоритм пошагово перебирает все вершины графа и назначает им метки, которые являются известным минимальным расстоянием от вершины источника до конкретной вершины. Рассмотрим этот алгоритм на примере.   
  
Присвоим 1-й вершине метку равную 0, потому как эта вершина — источник. Остальным вершинам присвоим метки равные бесконечности.

Далее выберем такую вершину W, которая имеет минимальную метку (сейчас это вершина 1) и рассмотрим все вершины в которые из вершины W есть путь, не содержащий вершин посредников. Каждой из рассмотренных вершин назначим метку равную сумме метки W и длинны пути из W в рассматриваемую вершину, но только в том случае, если полученная сумма будет меньше предыдущего значения метки. Если же сумма не будет меньше, то оставляем предыдущую метку без изменений.
![[Снимок экрана 2025-08-05 в 00.06.00.png]]
После того как мы рассмотрели все вершины, в которые есть прямой путь из W, вершину W мы отмечаем как посещённую, и выбираем из ещё не посещенных такую, которая имеет минимальное значение метки, она и будет следующей вершиной W. В данном случае это вершина 2 или 5. Если есть несколько вершин с одинаковыми метками, то не имеет значения какую из них мы выберем как W.  
  
Мы выберем вершину 2. Но из нее нет ни одного исходящего пути, поэтому мы сразу отмечаем эту вершину как посещенную и переходим к следующей вершине с минимальной меткой. На этот раз только вершина 5 имеет минимальную метку. Рассмотрим все вершины в которые есть прямые пути из 5, но которые ещё не помечены как посещенные. Снова находим сумму метки вершины W и веса ребра из W в текущую вершину, и если эта сумма будет меньше предыдущей метки, то заменяем значение метки на полученную сумму.
![[Снимок экрана 2025-08-05 в 00.08.36.png]]
Исходя из картинки мы можем увидеть, что метки 3-ей и 4-ой вершин стали меньше, тоесть был найден более короткий маршрут в эти вершины из вершины источника. Далее отмечаем 5-ю вершину как посещенную и выбираем следующую вершину, которая имеет минимальную метку. Повторяем все перечисленные выше действия до тех пор, пока есть непосещенные вершины.

![[Снимок экрана 2025-08-05 в 00.09.34.png]]


### Задача коммивояжера.
Задача коммивояжёра — одна из самых известных задач комбинаторной оптимизации, заключающаяся в поиске самого выгодного маршрута, проходящего через указанные города ровно по одному разу с последующим возвратом в исходный город.

Совершенно очевидно, что задача может быть решена перебором всех вариантов объезда и выбором оптимального.

**Задача о коммивояжере** (англ. _Travelling salesman problem, TSP_) — задача, в которой коммивояжер должен посетить N городов, побывав в каждом из них ровно по одному разу и завершив путешествие в том городе, с которого он начал. В какой последовательности ему нужно обходить города, чтобы общая длина его пути была наименьшей?

Варианты решения:
1. Перебор перестановок
Можно решить задачу перебором всевозможных перестановок. Для этого нужно сгенерировать все N! всевозможных перестановок вершин исходного графа, подсчитать для каждой перестановки длину маршрута и выбрать минимальный из них. Но тогда задача оказывается неосуществимой даже для достаточно небольших N. Сложность алгоритма O(N!×N).
2. Динамическое программирование по подмножествам
Задача о коммивояжере представляет собой поиск кратчайшего гамильтонова цикла в графе. **Гамильтоновым циклом** (англ. _Hamiltonian cycle_) называют замкнутый гамильтонов путь. **Гамильтоновым путём** (англ. _Hamiltonian path_) называется простой путь, проходящий через каждую вершину графа ровно один раз.
Задача о коммивояжере представляет собой поиск кратчайшего гамильтонова цикла в графе. Зафиксируем начальную вершину s и будем искать гамильтонов цикл наименьшей стоимости — путь от s до s, проходящий по всем вершинам (кроме первоначальной) один раз. Т.к. искомый цикл проходит через каждую вершину, то выбор s не имеет значения. Поэтому будем считать s=0.
Обозначим d[i][mask] как наименьшую стоимость пути из вершины i в вершину 0, проходящую (не считая вершины i) единожды по всем тем и только тем вершинам j, для которых maskj=1 (т.е. d[i][mask] уже найденный оптимальный путь от i-ой вершины до 0-ой, проходящий через те вершины, где maskj=1. Если maskj=0,то эти вершины еще не посещены).
Алгоритм поиска цикла будет выглядеть следующим образом:

- Начальное состояние — когда находимся в 0-й вершине, ни одна вершина не посещена, а пройденный путь равен 0 (т.е. i=0 и mask=0).
- Для остальных состояний (i≠0 или mask≠0) перебираем все возможные переходы в i-ую вершину из любой посещенной ранее и выбираем минимальный результат.
- Если возможные переходы отсутствуют, решения для данной подзадачи не существует (обозначим ответ для такой подзадачи как ∞).
Данное решение требует O(2n×n) памяти и O(2n×n2) времени.

_Точные методы_ не только находят некоторое решение, но и при _окончании_  своей работы доказывают, что это решение - наилучшее. Отметим следующие из них: _Полный перебор_ перестановок **n-1** чисел (стартовый город фиксирован). Практически бесполезен при **n > 15.** Направленный поиск с возвратами - перебор вариантов "относительно" некоторого решения с отсечением путей, имеющих длину большую, чем лучший к текущему моменту путь. _Метод ветвей и границ_ - наиболее эффективный из известных метод отсечения "неперспективных" узлов, за счёт анализа матрицы расстояний. При поиске оптимального решения строится бинарное дерево (в каждом узле порождаются **_2_** ветви: коммивояжёр идёт в некоторый город или не идёт в него). Линейное программирование применяется для минимизации с ограничениями линейной формы **d·x**, где **x** -искомый бинарный вектор размерности **_n(n-1)/2,_** компоненты которого **_xi_** равны **_1_** или **_0_**, в зависимости от того, входит **_i-_**я дуга в путь или нет. Вектор **d** (той же размерности) равен длинам дуг из сети дорог.
### Метод ветвей и границ.
МВГ - один из методов решения задачи комиявожера. 
На каждом шаге метода элементы разбиения (подмножества) подвергаются анализу – содержит ли данное подмножество оптимальное решение или нет. Если рассматривается задача на минимум, то проверка осуществляется путем сравнения нижней оценки значения целевой функции на данном подмножестве с верхней оценкой функционала.
Допустимое решение, дающее наименьшую верхнюю оценку, называют рекордом. Если оценка снизу целевой функции на данном подмножестве не меньше оценки сверху, то рассматриваемое подмножество не содержит решения лучше рекорда и может быть отброшено. Если значение целевой функции на очередном решении меньше рекордного, то происходит смена рекорда. Будем говорить, что подмножество решений просмотрено, если установлено, что оно не содержит решения лучше рекорда. Если просмотрены все элементы разбиения, алгоритм завершает работу, а текущий рекорд является оптимальным решением. В противном случае среди непросмотренных элементов разбиения выбирается множество, являющееся в определенном смысле перспективным. Оно подвергается разбиению (ветвлению). Новые подмножества анализируются по описанной выше схеме. Процесс продолжается до тех пор, пока не будут просмотрены все элементы разбиения.


![[Снимок экрана 2025-08-06 в 21.18.33.png]]
![[Снимок экрана 2025-08-06 в 21.18.42.png]]
### Гамильтонов путь в графе и его поиск
**Гамильтонов путь** в графе — это путь, который проходит через каждую вершину ровно один раз, за исключением начальной и конечной вершины, которые совпадают
**Эйлеров путь** в графе — это путь, который проходит через каждое ребро ровно один раз.

Т. Эйлера: Связный граф содержит эйлеров цикл тогда и только тогда, когда степень каждой его вершины есть чётное число.

Условия существования:

Для **Эйлерова цикла** (путь, который начинается и заканчивается в одной и той же вершине) в неориентированном графе все вершины должны иметь четную степень.

Для **Эйлерова пути** (не обязательно замкнутого) в неориентированном графе допускается наличие ровно двух вершин с нечетной степенью.

Достаточные условия гамильтонова графа:

**Теорема Дирака**: Пусть дан граф с n вершинами (n ≥ 3). Для существования гамильтонова цикла достаточно, чтобы степень каждой вершины была не меньше, чем n/2.

**Теорема Оре**: Для существования гамильтонова цикла в графе с n ≥ 3 вершинами достаточно, чтобы сумма степеней любых двух несмежных вершин была не меньше n.

#### эйлеров путь

Алгоритм Флёри:

Шаги:
1. Проверка условий:Убедиться, что граф связный (граф называется связным, если между любыми двумя его вершинами существует хотя бы один путь) и выполняет условия существования эйлерова пути.

2. Выбор начальной вершины:Если есть вершины с нечетной степенью, выбрать одну из них в качестве начальной. Иначе начать с любой вершины.

3. Итеративное удаление ребра: Выбрать ребро, инцидентное (Ребро графа называется инцидентным вершине, если эта вершина является одним из его концов) текущей вершине. Если это ребро - мост (его удаление делает граф несвязным), выбрать другое ребро. Удалить выбранное ребро и перейти в вершину, с которой оно было соединено
4. Повторять шаг 3 до тех пор, пока не будут пройдены все ребра

Алгоритм на основе поиска в глубину (DFS):

Идея в том, чтобы рекурсивно исследовать граф, удаляя ребра по мере их прохождения.

Если в какой-то момент вершина оказывается без не пройденных исходящих ребер, добавляем ее в путь.

#### гамильтонов путь
1. Полный перебор: Генерирует все возможные перестановки вершин и проверяет, образуют ли они гамильтонов путь.

2. Метод ветвей и границ: Рекурсивный алгоритм, который строит гамильтонов путь, постепенно добавляя вершины и используя оценки (границы) для отсечения бесперспективных ветвей поиска.

![[Снимок экрана 2025-08-06 в 21.40.34.png]]

![[Снимок экрана 2025-08-06 в 21.40.55.png]]
