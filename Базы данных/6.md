### Основные виды связей между различными типами объектов. 
В реляционной модели связи между сущностями (объектами) классифицируются по двум основным критериям: **мощности связи (cardinality)** и **степени обязательности участия (partipation)**.
Связи используются в построении ER-представления базы данных.
**Виды связей по мощности**

1. **Связь "один к одному" (1:1)** возникает, когда одному экземпляру сущности A соответствует ровно один экземпляр сущности B, и наоборот. Например, отношение между человеком и его биометрическим паспортом: у каждого человека только один такой документ, и каждый документ принадлежит одному человеку. В SQL это реализуется через внешний ключ с ограничением UNIQUE, гарантирующим уникальность связи. Истинные связи 1:1 встречаются реже, чем кажется на первый взгляд – часто они указывают на то, что сущности можно объединить в одну таблицу.

2. **Связь "один ко многим" (1:M)** – наиболее распространённый тип. Здесь экземпляр сущности A может быть связан с несколькими экземплярами сущности B, но каждый B принадлежит только одному A. Пример: отдел компании и его сотрудники. Один отдел включает многих сотрудников, но каждый сотрудник числится только в одном отделе. В реализации это выражается через внешний ключ в таблице "многих" (сотрудников), ссылающийся на первичный ключ таблицы "одного" (отдела).

3. **Связь "многие ко многим" (M:N)** существует, когда экземпляры сущности A связаны с несколькими экземплярами B, и наоборот. Классический пример – студенты и курсы: один студент посещает несколько курсов, и на одном курсе учится много студентов. Для реализации такой связи в реляционной модели требуется промежуточная таблица (ассоциативная сущность), которая содержит комбинации первичных ключей обеих сущностей. Например, таблица "Зачисления" (Enrollments) с полями StudentID и CourseID. Попытка реализовать M:N без промежуточной таблицы нарушает первую нормальную форму.

**Виды связей по обязательности участия**

1. **Тотальное (обязательное) участие** означает, что каждый экземпляр сущности должен участвовать в связи. Например: каждый заказ в интернет-магазине должен содержать хотя бы один товар (связь "Заказ-Товар"). В SQL строгая реализация тотального участия требует триггеров или сложных CHECK-ограничений, так как стандарт не имеет прямых механизмов для этого.

2. **Частичное (необязательное) участие** допускает существование экземпляров сущности без связи с другими сущностями. Например: сотрудник компании может не участвовать ни в одном проекте. Реализуется просто разрешением NULL во внешнем ключе.

"Связи – это кровеносная система базы данных. Их корректное проектирование определяет, будут ли данные живым организмом или мёртвым набором таблиц". Реализация связей через внешние ключи – механизм обеспечения этой "жизнеспособности", но проектировать их нужно исходя из семантики предметной области, а не технических удобств.
### Структура баз данных. Таблицы, поля, типы данных, свойства полей. 

Структура реляционных баз данных - это строгая система компонентов, обеспечивающая целостность и эффективность.

### **1. Таблицы (Tables / Relations)**

**Определение**:  
Основная структурная единица БД. Представляет собой **отношение** (relation) в математическом смысле:

- **Строки (Tuples / Records)** — экземпляры данных.
    
- **Столбцы (Attributes / Fields)** — характеристики данных.
    

**Принципы (по Дейту)**:

- Каждая таблица соответствует **одной сущности** предметной области (сотрудники, заказы).
    
- Порядок строк/столбцов не имеет значения (теория множеств).
    
- **Ключевое требование**: Отсутствие дубликатов строк (следует из определения отношения).
    

---

### **2. Поля (Fields / Attributes)**

**Определение**: Столбцы таблицы, описывающие свойства сущности.

**Пример**:

|Поле|Содержание|
|---|---|
|`EmployeeID`|Уникальный идентификатор|
|`Name`|ФИО сотрудника|
|`BirthDate`|Дата рождения|

---

### **3. Типы данных (Data Types)**

**Назначение**:  
Ограничивают домен (множество допустимых значений) поля.

**Основные типы (глава 5)**:

|Тип|Примеры|Описание|
|---|---|---|
|**Целочисленные**|`INT`, `SMALLINT`|Целые числа|
|**Вещественные**|`FLOAT`, `DECIMAL(10,2)`|Числа с плавающей точкой|
|**Строковые**|`VARCHAR(100)`, `CHAR(5)`|Текст фикс./переменной длины|
|**Дата/время**|`DATE`, `TIMESTAMP`|Даты и время|
|**Булевы**|`BOOLEAN`|`TRUE`/`FALSE`|
|**Бинарные**|`BLOB`|Файлы, изображения|

**Важно!** Дейт настаивает: выбор типа — это **ограничение домена** (например, `Salary DECIMAL(10,2) CHECK (Salary > 0)`).

### **4. Свойства полей (Constraints)**

Ограничения, обеспечивающие целостность данных (главы 5, 8):

#### **a) Обязательность**

- `NOT NULL` — запрет на пустые значения.
    

Name VARCHAR(100) NOT NULL

#### **b) Уникальность**

- `UNIQUE` — все значения в столбце уникальны.

Email VARCHAR(255) UNIQUE

#### **c) Первичный ключ**

- `PRIMARY KEY` — уникальный идентификатор строки (автоматически `NOT NULL + UNIQUE`).

EmployeeID INT PRIMARY KEY

#### **d) Внешний ключ**

- `FOREIGN KEY` — связь с первичным ключом другой таблицы.

DeptID INT REFERENCES Departments(DeptID)

#### **e) Проверочные условия**

- `CHECK` — пользовательские правила.

Age INT CHECK (Age >= 18)

#### **f) Значение по умолчанию**

- `DEFAULT` — автоматическое заполнение при вставке.

CreatedDate TIMESTAMP DEFAULT CURRENT_TIMESTAMP

### Способы создания и редактирования таблиц. Первичные и внешние ключи

Создание и модификация таблиц, а также работа с ключами рассматриваются как фундаментальные операции DDL.

**1. Создание таблиц (CREATE TABLE)**  
Таблицы создаются командой `CREATE TABLE`, определяющей:

- **Поля** (столбцы) с указанием типа данных:
```
    CREATE TABLE Студенты (
        Студент_ID INT, 
        ФИО VARCHAR(100),
```
- **Ограничения целостности**:
    
    - `PRIMARY KEY` (первичный ключ) – уникальный идентификатор строки:
 ```
       Студент_ID INT PRIMARY KEY
```
    - `NOT NULL` – обязательное заполнение,
        
    - `UNIQUE` – уникальность значений.
        

**Пример полного создания**:

```
CREATE TABLE Группы (
    Группа_ID INT PRIMARY KEY,
    Название VARCHAR(50) NOT NULL UNIQUE
);
```

---

**2. Редактирование таблиц (ALTER TABLE)**  
Основные операции:

- **Добавление/удаление столбца**:
```
    
    ALTER TABLE Студенты ADD COLUMN Телефон VARCHAR(15); 
    ALTER TABLE Студенты DROP COLUMN Телефон;
    
```
- **Изменение структуры**:
```
    
    ALTER TABLE Студенты ALTER COLUMN ФИО TYPE VARCHAR(150); -- смена типа
    ALTER TABLE Студенты RENAME COLUMN ФИО TO Полное_имя;   -- переименование
    
```
- **Управление ключами**:
```
    
    ALTER TABLE Студенты ADD PRIMARY KEY (Студент_ID);       -- добавление PK
    ALTER TABLE Студенты DROP CONSTRAINT PK_ключ;            -- удаление PK
```

**3. Первичные ключи (Primary Keys)**  
**Свойства**:

- Уникально идентифицируют строку (`UNIQUE`),
    
- Не допускают `NULL`,
    
- Неизменяемы (по мнению Дейта, изменение PK – признак ошибки проектирования).  
    **Типы**:
    
- **Простой ключ**: Одно поле (`ID INT PRIMARY KEY`),
    
- **Составной ключ**: Несколько полей:

```
  
    CREATE TABLE Зачетка (
        Студент_ID INT,
        Дисциплина_ID INT,
        Оценка INT,
        PRIMARY KEY (Студент_ID, Дисциплина_ID)  -- составной PK
    );
```

**4. Внешние ключи (Foreign Keys)**  
**Назначение**: Обеспечение ссылочной целостности. Связывают таблицы через `REFERENCES`.  
**Синтаксис**:

```
CREATE TABLE Студенты (
    ...
    Группа_ID INT,
    FOREIGN KEY (Группа_ID) 
        REFERENCES Группы(Группа_ID)  -- ссылка на PK таблицы "Группы"
        ON DELETE CASCADE            -- правило каскада
);
```

**Правила для операций**:

- `ON DELETE CASCADE` – удаление связанных записей,
    
- `ON DELETE SET NULL` – установка `NULL` при удалении родительской записи,
    
- `ON DELETE RESTRICT` – запрет удаления, если есть ссылки.

